{
  # Ворошилов Владислав ПИ20-3
  # Задание 1
  vec <-  c(1:10)
  typeof(vec)
  mode(vec)
  str(vec)
  # Из предложенного мной примера видно, что наиболее полную информацию предлагает
  # str(). Выводится тип объектов, х диапазон и перечисление в одну строку
  # mode() определил самый общий тип объектов, что намиеньшее количество информации
  # typeof() выводит конкретнйы тип объектов
} 

{
  # Задание 2
  w1 <- c(-12L, 4, "Level 2", 8.2, TRUE)
  w2 <- c(0, 56/6, FALSE, FALSE, 18)
  w3 <- c(Inf, NULL, NA, FALSE, 18, NaN)
  w4 <- c(Inf, NULL, NA, FALSE, 18L, NaN)
  w5 <- c(Inf, NULL, NA, FALSE, "18", NaN)
  w6 <- c(NULL)

  print(paste0("w1 type: ", typeof(w1), ", length: ", length(w1)))
  print(paste0("w2 type: ", typeof(w2), ", length: ", length(w2)))
  print(paste0("w3 type: ", typeof(w3), ", length: ", length(w3)))
  print(paste0("w4 type: ", typeof(w4), ", length: ", length(w4)))
  print(paste0("w5 type: ", typeof(w5), ", length: ", length(w5)))
  print(paste0("w6 type: ", typeof(w6), ", length: ", length(w6)))
  
  # w3 и w4 имеют тип double, потому что Nan и Inf имеют тип double, 
  # поэтому 18L в w4 преобразовывается к типу double, а других отличий в векторах нет.
}

{
  #Задание 3 
  w1 <- rep(c(0, -1, 1:3), times = 3) 
  w2 <- rep(c(0, -1, 1:3), each = 3) 
  w3 <- rep(c(0, -1, 1:3), each = 3, times = 2) 
  print(w1)
  print(w2)
  print(w3)
  # times повторяет всю последовательность
  # each каждый элемент повторяется
  # each , times сначала повторяется каждый элемент последовательности, 
  # а потом полученная последовательность повторяется
}

{
  #Задание 4
  vec <- seq(from=15, by = 5, length.out = 5)
  print(vec)
  # seq задаёт последовательность. Параметр from указывает, что последовательность начинается с 15 
  # by на разницу между соседними элементами последовательности (шаг последовательности)
  # length.out содержит в себе количество элементов в последовательности. 
  # Таким образом, я получил последовательность, начинающуюся с 15, с шагом 5, размером в 5 элементов
}

{
  #Задание 5 
  # seq_len эквивалентно вызову seq только с параметром length.out 
  # seq_len приинимает только один аргумент - length.out
  seq_len(10)
  seq(length.out=10)
}

{
  #Задание 6
  vec <- scan(what=integer())
  print(vec)
  # с помощью параметра what можно задать тип ожидаемых данных. В данном случае я сделал ввод целых чисел
  # при попытке ввести нецелое число возниикает ошибка
  #Ошибка в scan(what = integer()) :
  # 'scan()' ожидает 'an integer', а не 'TRUE'
}

{
  #Задание 7
  vec <- scan(what=character())
}

{
  #Задание 8
  vec
  fix(vec)
  vec
  edit(vec)
  vec
  # edit выполняет изменение in-place, не изменяя перменную, но при этом возвращая новый вектор
  # fix меняет вектор и перезаписывает его
}

{
  #Задание 9
  a<- c(7:4, 0)
  b<-c(8, 10.5, 0, -2, 9)
  print(a)
  print(b)
  print(a+b)
  print(a*b)
  print(a/b)
  print(paste0("Average for a: ", mean(a)))
  print(paste0("Average for b: ", mean(b)))
  print(paste0("Sum for a: ", sum(a)))
  print(paste0("Sum for b: ", sum(b)))
  
}

{
  #Задание 10
  vec <- c(1)
  typeof(vec)
  vec <- c(1, 1i)
  typeof(vec)
  vec <- c(1, 1L)
  typeof(vec)
  vec <- c(1L, 1i)
  typeof(vec)
  vec <- c(1, TRUE)
  typeof(vec)
  vec <- c(1L, TRUE)
  typeof(vec)
  vec <- c(1L, 1,  TRUE)
  typeof(vec)
  vec <- c(1i, TRUE)
  typeof(vec)
  vec <- c(1, "1")
  typeof(vec)
  vec <- c(1L, "1")
  typeof(vec)
  vec <- c(1i, "1")
  typeof(vec)
  vec <- c(1, 1i, 1L)
  typeof(vec)
  vec <- c(1, 1i, 1L, TRUE)
  typeof(vec)
  vec <- c(1, 1i, 1L, TRUE, "1")
  typeof(vec)
  vec <- c(1, 1i, 1L, TRUE, "1")
  typeof(vec)
  
  # Из полученных результатов проглядывается следующая иерархия. Чем тип выше в иерархии, тем  выше его приоритет,
  # То есть среди n-типов будет преобразовано всё к типу с наивысшим приоритетом
  # Иерархия
  # 1. character
  # 2. complex
  # 3. double
  # 4. integer
  # 5. logical
}

{
  # Задание 11
  print(c(1:3) + c(4:6))
  print(c(1:3) + c(1))
  print(c(1:3) + c("4", "5", "6"))
  print(c(1:3) + c("4", '5'))
  print(c(1:3) + c(T, T, T))
  print(c(1:3) + c(T, F))
  
  # 1. При сумме векторов равной длины с одинаковым типом происходит поэлементная сумма
  # 2. При сумме векторов разной длины с одинаковым типом происходит дополнение меньшего вектора до размера другого вектора 
  # первыми n элементами, где n разность длин векторов
  # 3. При сумме векторов разных типов происходит преобразование типов векторов по приинципу, описанному в задании 10
  # Если тип данных поддерживает арифметические операции, то они выполняются по правилам 1 и 2 
}

{
  # Задание 12
  vec.1 <- c(1:5)
  vec.2 <- c(1, 2, 3)
  vec.3 <- c(T, F, T, T)
  vec.4 <- c('1', '2', 'T', '4', 'F')
  vec.5 <- c(1i, 2i, 3i, 4i, 5i, 6i)
  (vec.1 & vec.2) || (vec.3 && vec.4) 
  # В первой скобке происходит поэлементная конъюнкция. Т.к. там только числа, среди которых нет 0, то результат равен TRUE
  # По этой причине сразу возращается TRUE
  !(vec.1 & vec.2) | (vec.3 & vec.5)
  #В первой скобке тоже самое выражене, что из прошлого примера, но с отрицанием. Поэтому левая часть равна False
  #Далее происходит поэлементное сочетание, результатом которого будет результат правой скобки
  # В правой скобек поэлементная конъюнкця векторов 3 и 5, которые приводятся к типу complex
  #В векторе 3 есть элемент FALSE, который при умножении встреиться в начале, на своём месте 
  # И при "достройки" вектора 3 до длины вектора 5. 
  # FALSE при конъюнкции возвращает FALSE, которые мы  видим в ответе. Все остальные конъюнкции возвращают TRUE
}

{
  #Задание 13
  (runif(100)*45 - 17 )%/% 1
  # Задаём последовательность длиной 10 с помощью runif(10). 
  # Наша последовательность лежит на отрезке [0;1]
  # Значит при умножении на n он станет [0;n]
  # Значит, чтобы настроить нижнюю границу - надо вычесть из диапазона 17
  # Тогда диапазон будет [-17;n-17]. Получаем уравнение 28= n - 17 => n = 28 + 17 = 45
  # С помощью целочисленного деления на 1 получаем целое число
}

{
  #Задание 14
  (((sample(x = 1:1000, size = 20, replace=TRUE) + 400) %/% 10) / (-20)) 
  # Задаём последовательность длиной 20 и отрезком [1:1000] с помощью sample(x = 1:1000, size = 20, replace=TRUE)
  # Если добавить 400, то получится отрезок [401;1400]. Похоже, что достаточно поделить этот промежуток на -200
  # Но в таком случае границы примут вид [-7;-2,005]. Чтобы этого не допустить, найдём целое от деления на 10
  # и, атким образом, избавимся от единички в промежутке, который примет вид [40;140]. Теперь просто поделим его на -20
  # Получилось [-7;-2]
  
}

{
  #Задание 15 
  vec <- scan(what=integer(), nmax = 5, quiet = T)
  # с помощью параметра what можно задать тип ожидаемых данных. В данном случае я сделал ввод целых чисел
  # nmax опередляет максимальное число введённых элементов
  # quiet определяет, не выводить ли количество элементов на экран после окончанмя ввода. По умолчанию равно FALSE
}

{
  #Задание 16
  w1 <- -3.3:4.67
  w2 <- rep(с(1:-2), 3)
  w3 <- w1^w2
  print(w1)
  print(w2)
  print(w3)
  # R достраивает векторы до одинаковой длины первыми n элементами, где n - разница длин векторов
}

{
  #Задание 17
  alphabet = c('А',"Б","В","Г","Д","Е","Ё","Ж","З","И","Й","К","Л","М","Н","О","П","Р","С","Т","У","Ф","Х","Ц","Ч","Ш","Щ","Ъ","Ы","Ь","Э","Ю","Я")
  n = as.integer(readline("Enter N: "))
  sample(alphabet, n, replace = TRUE)
  # в функции sample есть аргумент x, в который может быть передан вектор, из которого функция будет выбирать случайный элемент
}

{
  #Задание 18
  vec <- c(2, 1, -1, 4, 5, 0)
  print(vec)
  sort(vec)
  print(vec)
  order(vec)
  print(vec)
  # sort возвращает отсортированный вектор, order возвращает индексы элементов вектора в порядке, при котором вектор будет отсортирован
}

{
  #Задание 19 
  a <- scan(what=integer())
  b <- scan(what=integer())
  z <- as.logical(a %% b)
  !z
  # Если число из вектора a кратно числу из вектора b, то остаток от деления равен нулю
  # Иначе он будет отличен от нуля. Найдём остаток от деления a на b и преобразуем в логический тип 
  # Так как у кратных чисел остаток от деления 0, то он преобразуется в FALSE
  # Если остаток от деления не равен 0, то он преобразуется в TRUE
  # По условию нам требуется при кратности - TRUE, иначе - FALSE
  # Поэтому применим к вектору z инверсию
}

{
  # Задание 20
  h1 <- vector(mode="double", length=20)
  mode(h1)
  length(h1)
  mode
  length
  
  h2 <- vector(mode <- "double", length <- 21)
  mode(h2)
  length(h2)
  mode
  length
  
  # Когда мы объявляем переменные mode и length с помощью символа =, то они остаются в зоне видимости только 
  # для вектора h1. Мы не можем к ним обратиться без помощи функций mode() и length()
  # При объявлении h2 мы использовали <-. Переменные mode и length теперь находятся в глобальной области видимости.
  # Теперь к ним можно обратиться просто по имени, без использования функций. 
}
